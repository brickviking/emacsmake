#+TITLE: Emacs Make script
#+AUTHOR: brickviking
#+EMAIL: brickviking@gmail.com

* Introduction
This is a simple script to create Emacs from its source code. About the only thing missing from
this is a licence, I haven't come up with a usable licence yet.

* Readme, in org format
  :PROPERTIES:
  :header-args: org :tangle README.org
  :END:


#+BEGIN_SRC org -i
,* Introduction
This is a very simple wrapper script to distclean, configure, make, install and execute Emacs.
Changes can be made to the variables inside the script, which will help drive how Emacs can be
compiled, installed and executed.

,* Variables and requirements
First off, you'll need to install the source code to Emacs, adjust =EMACSCOMPILEHOME=. You can either
fetch and extract a static tarball of the source, or you can access either of the git repositories.

Because you're compiling Emacs, you can choose which libraries to compile Emacs with; adjust the
=CONFIGPARAMS= array for this. You might want to check the output of =./configure --help= from
within the source directory to see what parameters are supported. This will include choosing the
place to put the compiled version of Emacs, adjust =EMACSHOME=. Note that this is the root of the
tree where the whole of Emacs will eventually live, not the location of the Emacs binary
itself. Usually directories will be created below this point for the libraries, the binaries and the
compiled lisp code to live. The usual place that is selected if you don't specify it would be
=/usr/local=, just as with a lot of other configure-based build systems.


,* Executing Emacs
At the moment, this script will run Emacs using the =with-emacs.sh= script, available from
https://github.com/alphapapa/with-emacs.sh - if you wish to run the compiled Emacs from anywhere not
already on the user's =PATH=, you will want to either add the installation directory (of the Emacs
binary): 
,#+BEGIN_QUOTE bash 
$ export PATH=${PATH}:${HOME}/bin/<new-location>/bin/emacs 
,#+END_QUOTE
as an example, or edit =with-emacs.sh= suitably to run the Emacs binary from a new location. Don't
forget to install the script somewhere on your =PATH=.

To supply a different configuration directory to execute Emacs with, adjust EMACSCONFHOME. This will
affect the running of with-emacs.sh.

,* Future directions
At this stage, I haven't got the foggiest idea what else I need, though I've already simplified this
by removing the whole "execute Emacs" stage, leaving that up to the with-emacs.sh script.

The usual applies to anyone who wants to report bugs, issues or even suggestions, check out the
issues section of this project.

#+END_SRC
* Main file
    :PROPERTIES:
    :header-args: bash :tangle emacsmake :tangle-mode (identity #o755)
    :END:

** Header and Changelog
A few notes made about things added/changed, along with a long-term target to meet for Emacsen
versions earlier than 28.0.50. Heck, 18.x (and earlier beasts) were done on far wimpier machines and
earlier versions (13-18.58) predated the autoconf software suite which wasn't released until 1991.

#+BEGIN_SRC bash
#!/bin/bash
#
# v0.1 Initial cut, should be mostly complete.
# v0.2 Changes to account for mistakes I made.
# v0.3 rework of environment variables.
# v0.4 added distclean, maintainerclean, and run everything.
# v0.5 Renamed reference from emacs-sandbox to with-emacs as upstream has renamed.
# v0.6 Finally added link to with-emacs.sh - it's about time.
#      Added comment for checking number of args at runtime.
# v0.7 Added in a do-almost-all (clean, configure, make).
# v0.8 Added some commented out options (lucid and motif).
# v0.8.1 Twiddled with config, error's only in the docs.
# v0.8.2 fixed docs for config with ugly hack.
# v0.9 Planning install upgrade to symlink the emacs binary to emacs-${VER}-$[WMGR}
# v0.10 Reworked all the pushd/popd to be quiet, by redirecting their output to /dev/null.
# v0.11 Created new param to combine make and install, deliberately doesn't include config.
#
# TODO: rework for versions of Emacs earlier than 28.0.50, as there's no makefile until the
#       configure phase. Still doesn't work for much earlier than 23 - 18.59 has no configure.
#+END_SRC

** Parameters

So far, the only thing of note here is that we need a specific directory to be explicitly mentioned
so that calling this from sudo doesn't bork with messages such as:
#+BEGIN_QUOTE
/home/viking/bin/emacsmake: line 157: pushd: /root/src/c/emacs: No such file or directory
#+END_QUOTE

Anyhow, there are some other tweakable values here which make sense except perhaps the playpen,
which ends up being my own personal settings testbed, so I don't blow away my main configuration.

Another thoughtâ€”we could perhaps pull in our CONFIGPARAMS from a created-at-first-run file.
The concept would be:
+ If we don't have a defaults file already
  + prompt user for "Choose, or defaults" (*)
  + write file back (for next time)
+ otherwise, read that file, and prompt user
  + Defaults are ....., do you wish to change these?
  + if so, select other defaults
  + write file back (for next time)

(*) We need to tweak EMACSCOMPILEHOME, EMACSHOME and CONFIGPARAMS. The other two (EMACSCONFHOME and
EMACSRUNARGS) aren't needed for compiling, merely for running.

Currently variables just get set to whatever made sense in the script, but there's no reason why we
can't support env vars from the outside either.

#+BEGIN_SRC bash -i
#######################
# Modifiable parameters
# You WILL want to fiddle with these if you don't want the args I chose
# This WILL break if the user running (EUID) isn't the same as the user owning the source directory
# i.e. if there's no /root/src/c/emacs
#EMACSCOMPILEHOME="${HOME}/src/c/emacs" # Should be specific, not user-relative

EMACSCOMPILEHOME="/h3/viking/src/c/hosts/gnu/emacs"
# Place to put Emacs (root of tree)
# EMACSHOME="${HOME}/bin/emacs-playpen"
EMACSHOME="/usr/local"
# Default, but check the configMe functions further down
CONFIGPARAMS=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-xwidgets"
    "--with-x-toolkit=gtk3" # for completeness's sake
    "--prefix=${EMACSHOME}" )
WMGR=gtk3
# This gets used to run with-emacs.sh with custom directory
EMACSCONFHOME="${HOME}/.emacs-playpen"
EMACSRUNARGS=(
    "-d"
    "${EMACSCONFHOME}" )
#+END_SRC

** Functions
*** Help function

The boilerplate help just in case I forgot what switches I coded. Uses UNIX syntax (-x) not Microsoft (/x). There's also a slight bug with CONFIGPARAMS
if I decide I want to show non-default window toolkits. So far I've added
gtk, gtk2, gtk3 (the default), lucid and Motif toolkits. I haven't bothered
with -nw, as I'm always on a desktop with an Xorg server running.

#+BEGIN_SRC bash -i
###########
# Functions

# Help function, usage(), ugly hack to put in toolkits
CONFIGPARAMSGTK=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=gtk" # for completeness's sake
    "--prefix=${EMACSHOME}"
)
CONFIGPARAMSGTK2=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=gtk2" # for completeness's sake
    "--prefix=${EMACSHOME}"
)
CONFIGPARAMSGTK3=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-xwidgets"
    "--with-x-toolkit=gtk3" # for completeness's sake
    "--prefix=${EMACSHOME}")
CONFIGPARAMSLUCID=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=lucid"
    "--prefix=${EMACSHOME}")
CONFIGPARAMSMOTIF=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=motif"
    "--prefix=${EMACSHOME}")

helpMe() {
    echo "$0: Emacs recompiler script"
    echo "   -h   help (this text)"
    echo "   -d   Runs 'make distclean'"
    echo "   -D   Runs 'make maintainer-clean'"
    echo "   -a   Runs  every step except execute"
    echo "   -e   run every step; distclean, configure, make, install, run"
    echo "        default Emacs binary location is ${EMACSHOME}"
    echo "   -c   run ./configure with params ${CONFIGPARAMS[@]}"
    echo "   -cg  run ./configure with params ${CONFIGPARAMSGTK[@]}"
    echo "   -cg2 run ./configure with params ${CONFIGPARAMSGTK2[@]}"
    echo "   -cl  run ./configure with params ${CONFIGPARAMSLUCID[@]}"
    echo "   -cm  run ./configure with params ${CONFIGPARAMSMOTIF[@]}"
    echo "   -m   compile (no install), runs make"
    echo "   -i   install to ${EMACSHOME}, runs make install"
    echo "   -mi  combines compile and install steps"
    echo "   -r   execute from ${EMACSHOME}, runs  with-emacs.sh -d "${EMACSCONFHOME}" -i quelpa-use-package "
    echo "   -u   uninstall from ${EMACSHOME}, runs make uninstall"
}
#+END_SRC

*** Cleaning scripts distclean/maintainer-clean

Distclean basically removes almost everything that didn't come with the source code, and
maintainer-clean removes everything that was generated, leaving only the original code.  I'm not
sure about the distinction, though I used to know. One point I've noted is that neither command is
gatekeepered, i.e. they both take immediate effect without the ability to back out.

#+BEGIN_SRC bash -i
# Runs make distclean, but only if the configure step had created one.
# TODO: no chance to break out of this, perhaps we should offer that
cleanMe() {
    if [[ -f Makefile ]]; then
	echo "This will REMOVE all compiled files including makefiles"
	make distclean
    else
	echo "Makefile not found, skipping"
    fi
}

# Same proviso as above, this command takes immediate effect
cleanMeGood() {
    if [[ -f Makefile ]]; then
	echo "This will REMOVE all compiled files including makefiles"
	make maintainer-clean
    else
	echo "Makefile not found, skipping"
    fi
}
#+END_SRC

*** Configure Emacs for compilation

It's pretty obvious what this does, though it does presume we're in the correct directory, which we
should be by the time we get here. Heck, if we weren't, something went badly wrong.

I learned to specify the location of the configure directly, so I don't accidentally pick up on a
preinstalled configure somewhere in the ${PATH}.

#+BEGIN_SRC bash -i
# Runs configure phase
configMe() { # This just does GTK3, other command switches toggle
    ./configure "${CONFIGPARAMS[@]}"
}

# Should support the GTK1 crowd but here, just grabs gtk3
configMeGTK() {
CONFIGPARAMS=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=gtk"
    "--prefix=${EMACSHOME}" )
    WMGR=gtk # (might be gtk3)
    ./configure "${CONFIGPARAMS[@]}"
}

# Should support the GTK2 crowd too
configMeGTK2() {
CONFIGPARAMS=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=gtk2"
    "--prefix=${EMACSHOME}" )
    WMGR=gtk2
    ./configure "${CONFIGPARAMS[@]}"
}


# Default unless something else chosen, simply call configMe
configMeGtk3() {
    configMe
}

# Choose this if you never installed gtk - crazy, huh?
configMeLucid() {
CONFIGPARAMS=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=lucid"
    "--prefix=${EMACSHOME}" )
    WMGR=lucid
    ./configure "${CONFIGPARAMS[@]}"
}

# Choose this if you actually have a Motif or LessTif
configMeMotif() {
CONFIGPARAMS=(
    "--with-modules"
    "--with-imagemagick"
    "--with-cairo"
    "--with-x-toolkit=motif"
    "--prefix=${EMACSHOME}" )
    WMGR=motif
    ./configure "${CONFIGPARAMS[@]}"
}

#+END_SRC

*** Make command

The only note here is that we force a full recompile so we don't accidentally install stale .elc
files from previous compiles.

#+BEGIN_SRC bash -i
# Runs make (hopefully we ran configure first)
makeMe() {
    if [[ -f Makefile ]]; then
	make bootstrap -j4 # because we want stale .elc files regenned
    else
	echo "No Makefile found, perhaps run with -c first?"
    fi
}
#+END_SRC

*** Install/uninstall

This is a way to find out what I already compiled, if I compiled it. We start off with a default
of gtk3 in WMGR, which only changes if we find something specific. We don't really have to cut
off the pattern itself and it would save us a step through cut.

If we compiled without a toolkit altogether, this will have to be added to, as there'd be no other
switches to look for. There must be some way of getting a non-X emacs compiled too.

#+BEGIN_SRC bash -i
# Find what I made already, this is normally called from installMe
whatMadeMe() {
    # Piece to load into an array so I can parse the --with-x-toolkit parameter
    # VERY sensitive to configure output - if it changes, then this won't work.
    # If I search for $ ./configure I'll find the right line.
    if [[ -f config.log ]]; then
        mapfile -t TOOLKIT < <(sed -n '/\$ .\/configure/p' config.log | cut -c17-)
        for this in ${TOOLKIT[@]}; do
            case "${this}" in
                "--with-x-toolkit=gtk") WMGR=gtk ;; # Works out to be gtk3 here
                "--with-x-toolkit=gtk2") WMGR=gtk2 ;;
                "--with-x-toolkit=gtk3") WMGR=gtk3 ;;
                "--with-x-toolkit=lucid") WMGR=lucid ;;
                "--with-x-toolkit=motif") WMGR=motif ;;
            esac # We can simply ignore everything else
        done # for this in ${TOOLKIT}
        printf "Toolkit is: %s\n" ${WMGR}
    else
        echo "I don't think you ran configure in ${EMACSCOMPILEHOME}. Please rerun emacsmake with a -c parameter"
        popd >/dev/null # just to keep the stack straight
        exit 1 # Shouldn't really exit here
    fi
}
#+END_SRC

This piece copies the generated emacs binary at the destination to a backup that has the X toolkit
name appended.

#+BEGIN_SRC bash -i
# This copies the delivered binary ${EMACSHOME}/bin/emacs${VERSION} to emacs-${VERSION}-$[WMGR}
# which will be something like emacs-29.1.50-{gtk2,gtk3,lucid,motif}
# May not work for versions earlier than 28
copyMe() {
    # If we fail to find an emacs here, we failed to install
    if [[ -f ${EMACSHOME}/bin/emacs ]]; then
        EMACSTGT="$(readlink ${EMACSHOME}/bin/emacs)"
        echo "Linking ${EMACSHOME}/bin/${EMACSTGT} to ${EMACSHOME}/bin/${EMACSTGT}-${WMGR}"
        # There should perhaps be a sudo/doas here
        sudo cp -iv ${EMACSHOME}/bin/${EMACSTGT} ${EMACSHOME}/bin/${EMACSTGT}-${WMGR}
    else
        echo "$0: we couldn't find an emacs at ${EMACSHOME} or ${WMGR} isn't set."
    fi
}

#+END_SRC

This should by rights require the user to use sudo for this phase, but I have no clue as to what's
on a target machine for sudo permissions, if the user even has sudo rights.  Otherwise, it's a stock
standard install-emacs-to-target-directory at ${EMACSHOME} specified earlier in the PARAMS section.
One point not in the defaults is to copy the binary to a file that has the toolkit embedded in the
name.

#+BEGIN_SRC bash -i
# Runs the install phase (currently don't need sudo, but would have normally done)
installMe() {
    # echo "This will require you to enter in your password" # only needed for system dirs
    # sudo make install
    # TODO: should check that there's an Emacs binary first, but I don't know where that will be
    # First, find out what we made from what's been left behind in the last compile
    whatMadeMe
    if [[ -z ${WMGR} ]]; then
        echo "No toolkit selected, you should probably have run emacsmake -c"
    fi
    # There should perhaps be a sudo/doas here
    sudo make install
    copyMe
}

# Uninstall from $EMACSHOME
uninstallMe() {
    # The only requirements are that I've installed Emacs at EMACSHOME
    # and NOT reconfigured Emacs since
    if [[ -f "${EMACSHOME}/bin/emacs" ]]; then
        make uninstall
    else
        echo "Are you sure you installed Emacs to ${EMACSHOME}?"
    fi
}

#+END_SRC

*** Running

This runs the just-installed Emacs from a config in sandbox, so I don't hose the main config.  It
does depend on an ancillary script called with-emacs.sh, which came from another place.  It's not
mandatory to have this script for anything other than running Emacs with the config.  I just hope I
made a note of where to get it from, if I don't have it here on the local machine.

#+BEGIN_SRC bash -i
# Assuming everything else is done, runs compiled Emacs from install
runMe() {
    pushd "${EMACSHOME}"
    RETVAL=$( with-emacs.sh "${EMACSRUNARGS[@]}" )
    if [[ "${RETVAL}" != 0 ]]; then
        echo "Completed with ${RETVAL}"
    else
        echo "Completed with success"
    fi
    popd >/dev/null
}
#+END_SRC

*** Do-everything section

To call this, we just string all the sections together in a sequence. I've made no attempt to
support multiple stages, and have explicitly disallowed this by only allowing one arg down further
in main().

#+BEGIN_SRC bash -i
# Do almost everything
execMakeMe() {
    cleanMe # it's a distclean
    configMe
    makeMe
}

# Do everything except runMe - may require sudo
execMe() {
    execMakeMe # distclean, config and make
    installMe # Don't add copyMe to this, it's called from here already
#    runMe
}

#+END_SRC

** Main

This handles the arg matching, checks if we have a with-emacs.sh, and notifies us if we don't.
It's assumed we know how to get this from Github if we don't have it, perhaps an incorrect
assumption. It's available from Github at the following link (assuming he didn't remove it):
https://github.com/alphapapa/with-emacs.sh

We explicitly disallow multiple stages from being run, as we need to process things in a certain
order and it's too complex for me to track what stages I've set, especially if I try doing install
folllowed by uninstall, we'd have to reorder this so the uninstall was done first even if we
specified it last.

I've also not made any attempt at using getopts, as I feel it's simply quicker to roll my own.
However, I could have used short/long switches like the following:

#+BEGIN_QUOTE bash -i
# Need a getopts-style processor here, or I could simply roll my own. Quicker to roll.
# args=$(getopt -n "$0" -o cdDe:hmiru -l emacs:,config,distclean,maintainerclean,help,make,install,run,uninstall -- "$@") || { usage; exit 1; }

# eval set -- "$args"
# The while true won't work, as we need to run steps in order, not in the order the args are processed.
# TODO: we could handle multiple x/y/z in order, like this:
#    each arg read, sets val, then 
#+END_QUOTE

The -e:/--emacs: switch was the precursor for the "run Emacs from this location instead" function
from with-emacs.sh, but as the script does stuff better than I would have done, I left that up to
the secondary script. It's not written by me, and the style is quite different - presumably someone
who knows what they're doing.

#+BEGIN_SRC bash -i
########
# main()

# First, let user know about with-emacs.sh if they don't already have it installed
SANDBOX_LOCATION=$(type -p with-emacs.sh)
if [[ -z "${SANDBOX_LOCATION}" ]]; then
    echo "You do not have with-emacs.sh (check README.org), you should probably grab this"
    echo "from the following URL: https://github.com/alphapapa/with-emacs.sh"
    echo "so you can run Emacs from a sandboxed location."
    echo "Continuing anyhow."
fi
unset SANDBOX_LOCATION

if [[ -n $2 ]]; then # In short, if 2 or more args
    echo "$0: Too many arguments, we only need one of the following"
    helpMe
elif [[ -n $1 ]]; then
    case $1 in 
        "-h"|"--help"|"-?") helpMe ;;
        "-d") pushd "${EMACSCOMPILEHOME}" >/dev/null
              cleanMe
              popd >/dev/null ;;
	"-D") pushd "${EMACSCOMPILEHOME}" >/dev/null
              cleanMeGood
              popd >/dev/null ;;
        "-a") pushd "${EMACSCOMPILEHOME}" >/dev/null
              execMakeMe
              popd >/dev/null ;;
        "-e") pushd "${EMACSCOMPILEHOME}" >/dev/null # Eventually changes to ${EMACSHOME}
              execMe
              popd >/dev/null ;;
        "-c") pushd "${EMACSCOMPILEHOME}" >/dev/null
              configMe
              popd >/dev/null ;; # Uses GTK3 with xwidgets
        "-cg") pushd "${EMACSCOMPILEHOME}" >/dev/null
              configMeGTK
              popd >/dev/null ;;
        "-cg2") pushd "${EMACSCOMPILEHOME}" >/dev/null
              configMeGTK2
              popd >/dev/null ;;
        "-cl") pushd "${EMACSCOMPILEHOME}" >/dev/null
              configMeLucid
              popd >/dev/null ;;
        "-cm") pushd "${EMACSCOMPILEHOME}" >/dev/null
              configMeMotif
              popd >/dev/null ;;
        "-m") pushd "${EMACSCOMPILEHOME}" >/dev/null
              makeMe
              popd >/dev/null ;;
        "-i") pushd "${EMACSCOMPILEHOME}" >/dev/null
              installMe
              popd >/dev/null ;;
        # Let's do this all here
        "-mi") pushd "${EMACSHOME}">/dev/null
              makeMe
              installMe
              popd >/dev/null ;;
        "-r") pushd "${EMACSHOME}">/dev/null
              runMe
              popd >/dev/null ;;
	"-u") pushd "${EMACSCOMPILEHOME}" >/dev/null
              uninstallMe
              popd >/dev/null ;;
        # Find out what we have before
        "-w") pushd "${EMACSCOMPILEHOME}" >/dev/null
              whatMadeMe
              popd >/dev/null ;;
        ,*) pushd "."
              helpMe ;;
    esac
else # We don't have $1
    helpMe
fi

echo "Ending... bye"

#+END_SRC
* Makefile
    :PROPERTIES:
    :header-args: makefile :tangle Makefile
    :END:

This is a dirt-simple Makefile that will hopefully install emacsmake into a system-wide location.
It will need several runs at this, and I need to remember that recipes start off with a flush-left
line, followed by tabbed recipe instructions.

I deliberately haven't used "install" as I don't know what it does. I've also embedded a sudo inside
the makefile, which probably isn't a great idea either, but hey, it's my own machine. This is also
not for use on a Windows or MS-DOS/FreeDOS install.

#+BEGIN_SRC makefile -i
# Dirt-simple Makefile to install the emacsmake script
# v0.1 Initial cut - it only has to install one thing.

DESTDIR = /usr/local/bin

install: emacsmake
	@sudo cp -v emacsmake ${DESTDIR}/
	@sudo chmod -v +x ${DESTDIR}/emacsmake

uninstall:
	@sudo rm -v ${DESTDIR}/emacsmake


#+END_SRC

* Conclusions
This was originally a fairly clean script, which would have been easy enough to understand without
the extra descriptions. There's not a lot to this one, but I felt I needed to add a little
clarification at certain spots. I've also tried to make it more "portable" between Emacs versions.

There's also no config file, and one could be used to help clean the script up. Reasonable defaults
would still be needed.

* Bits to add

